/*
К каким негативным последствиям может привести данный фрагмент кода, и как это исправить?
Приведите корректный пример реализации.
// потрбление
var justString string // Глобальная переменная может оставаться в памяти весь период работы программы.

func someFunc() { // объявляем функцию
    v := createHugeString(1 << 10) // Создаем очень большую строку. Она остается в памяти, пока на нее есть ссылки.
    justString = v[:100] // Присваиваем глобальной переменной часть большой строки.
	// Негативное последствие: 'v' не будет удалена сборщиком мусора, так как 'justString' ссылается на ее часть.
	// Это может привести к утечкам памяти, особенно если 'createHugeString' создает очень большие строки.
}

func main() {
    someFunc()
    }
// Исправление: Перенести 'justString' в локальную область видимости функции, чтобы сократить время ее жизни.
// Это позволит сборщику мусора удалить и 'justString', и исходную 'v', как только они станут не нужны.
*/

package main

import "fmt"

func createHugeString(size int) string {
	return string(make([]byte, size)) // заглушка
}

func someFunc() string {
	v := createHugeString(1 << 10) // Создание большой строки
	justString := v[:100]          // Создание новой строки с нужными данными
	return justString              // Возврат строки, теперь память может быть освобождена
}
func main() {
	justString := someFunc()
	fmt.Println(justString)
}
